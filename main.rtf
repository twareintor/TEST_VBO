{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fmodern Courier;}}
{\colortbl\red0\green128\blue0;\red0\green0\blue255;\red0\green0\blue0;}
{\info{\comment Generated by the SynEdit RTF exporter}
{\title main.rtf}}

\deflang1033\pard\plain\f0\fs20 \cf0 /**************************
\par  * Includes
\par  *
\par  **************************/
\par 
\par \cf1 #include <windows.h>
\par \cf0 // application specific:
\par \cf1 #include <fstream>
\par #include <gl/gl.h>
\par #include <string.h>
\par \cf0 // #include <gl/glu.h>					// 
\par 
\par \cf1 #include <gl/glext.h>					\cf0 // 
\par 
\par ////////////////////////////////////////////////////////////////////////////////////////////////////
\par 
\par \cf2 PFNGLGENBUFFERSPROC 				glGenBuffers;
\par PFNGLBINDBUFFERPROC 				glBindBuffer;
\par PFNGLBUFFERDATAPROC 				glBufferData;
\par PFNGLVERTEXATTRIBPOINTERPROC 		glVertexAttribPointer;
\par PFNGLENABLEVERTEXATTRIBARRAYPROC 	glEnableVertexAttribArray;
\par 
\par PFNGLCREATESHADERPROC 				glCreateShader;
\par PFNGLSHADERSOURCEPROC 				glShaderSource;
\par PFNGLCOMPILESHADERPROC 				glCompileShader;
\par PFNGLCREATEPROGRAMPROC 				glCreateProgram;
\par PFNGLATTACHSHADERPROC 				glAttachShader;
\par PFNGLBINDATTRIBLOCATIONPROC 		glBindAttribLocation;
\par PFNGLLINKPROGRAMPROC 				glLinkProgram;
\par PFNGLUSEPROGRAMPROC 				glUseProgram;
\par PFNGLGETSHADERINFOLOGPROC			glGetShaderInfoLog;
\par 
\par \cf1 void\cf2  *GetAnyGLFuncAddress(\cf1 const\cf2  \cf1 char\cf2  *name);
\par 
\par 
\par \cf1 void\cf2  InitVBO(\cf1 void\cf2 );
\par 
\par 
\par \cf1 int\cf2  TestVBO(\cf1 void\cf2 );
\par 
\par \cf1 int\cf2  TestShaders(\cf1 void\cf2 );
\par 
\par \cf1 const\cf2  \cf1 char\cf2 * filetobuf(\cf1 const\cf2  \cf1 char\cf2 * szFNm);
\par 
\par \cf1 void\cf2  buftofile(\cf1 const\cf2  \cf1 char\cf2 * szFNm, \cf1 const\cf2  \cf1 char\cf2 * szBuf);
\par 
\par 
\par 
\par \cf0 /**************************
\par  * Function Declarations
\par  *
\par  **************************/
\par 
\par \cf2 LRESULT CALLBACK WndProc (HWND hWnd, UINT message,
\par WPARAM wParam, LPARAM lParam);
\par \cf1 void\cf2  EnableOpenGL (HWND hWnd, HDC *hDC, HGLRC *hRC);
\par \cf1 void\cf2  DisableOpenGL (HWND hWnd, HDC hDC, HGLRC hRC);
\par 
\par 
\par \cf0 /**************************
\par  * WinMain
\par  *
\par  **************************/
\par 
\par \cf1 int\cf2  WINAPI WinMain (HINSTANCE hInstance,
\par                     HINSTANCE hPrevInstance,
\par                     LPSTR lpCmdLine,
\par                     \cf1 int\cf2  iCmdShow)
\par \{
\par     WNDCLASS wc;
\par     HWND hWnd;
\par     HDC hDC;
\par     HGLRC hRC;        
\par     MSG msg;
\par     BOOL bQuit = FALSE;
\par     \cf1 float\cf2  theta = 0.0f;
\par 
\par     \cf0 /* register window class */
\par \cf2     wc.style = CS_OWNDC;
\par     wc.lpfnWndProc = WndProc;
\par     wc.cbClsExtra = 0;
\par     wc.cbWndExtra = 0;
\par     wc.hInstance = hInstance;
\par     wc.hIcon = LoadIcon (NULL, IDI_APPLICATION);
\par     wc.hCursor = LoadCursor (NULL, IDC_ARROW);
\par     wc.hbrBackground = (HBRUSH) GetStockObject (BLACK_BRUSH);
\par     wc.lpszMenuName = NULL;
\par     wc.lpszClassName = "GLSample";
\par     RegisterClass (&wc);
\par 
\par     \cf0 /* create main window */
\par \cf2     hWnd = CreateWindow (
\par       "GLSample", "OpenGL Sample", 
\par       WS_CAPTION | WS_POPUPWINDOW | WS_VISIBLE,
\par       20, 20, 256, 256,
\par       NULL, NULL, hInstance, NULL);
\par 
\par     \cf0 /* enable OpenGL for the window */
\par \cf2     EnableOpenGL (hWnd, &hDC, &hRC);
\par 
\par     \cf0 /* program main loop */
\par \cf2     \cf1 while\cf2  (!bQuit)
\par     \{
\par         \cf0 /* check for messages */
\par \cf2         \cf1 if\cf2  (PeekMessage (&msg, NULL, 0, 0, PM_REMOVE))
\par         \{
\par             \cf0 /* handle or dispatch messages */
\par \cf2             \cf1 if\cf2  (msg.message == WM_QUIT)
\par             \{
\par                 bQuit = TRUE;
\par             \}
\par             \cf1 else
\par \cf2             \{
\par                 TranslateMessage (&msg);
\par                 DispatchMessage (&msg);
\par             \}
\par         \}
\par         \cf1 else
\par \cf2         \{
\par             \cf0 /* OpenGL animation code goes here */
\par \cf2             TestVBO();
\par             SwapBuffers(hDC);
\par         \}
\par     \}
\par 
\par     \cf0 /* shutdown OpenGL */
\par \cf2     DisableOpenGL (hWnd, hDC, hRC);
\par 
\par     \cf0 /* destroy the window explicitly */
\par \cf2     DestroyWindow (hWnd);
\par 
\par     \cf1 return\cf2  msg.wParam;
\par \}
\par 
\par 
\par \cf0 /********************
\par  * Window Procedure
\par  *
\par  ********************/
\par 
\par \cf2 LRESULT CALLBACK WndProc (HWND hWnd, UINT message,
\par                           WPARAM wParam, LPARAM lParam)
\par \{
\par 
\par     \cf1 switch\cf2  (message)
\par     \{
\par     \cf1 case\cf2  WM_CREATE:
\par         \cf1 return\cf2  0;
\par     \cf1 case\cf2  WM_CLOSE:
\par         PostQuitMessage (0);
\par         \cf1 return\cf2  0;
\par 
\par     \cf1 case\cf2  WM_DESTROY:
\par         \cf1 return\cf2  0;
\par 
\par     \cf1 case\cf2  WM_KEYDOWN:
\par         \cf1 switch\cf2  (wParam)
\par         \{
\par         \cf1 case\cf2  VK_ESCAPE:
\par             PostQuitMessage(0);
\par             \cf1 return\cf2  0;
\par         \}
\par         \cf1 return\cf2  0;
\par 
\par     \cf1 default\cf2 :
\par         \cf1 return\cf2  DefWindowProc (hWnd, message, wParam, lParam);
\par     \}
\par \}
\par 
\par 
\par \cf0 /*******************
\par  * Enable OpenGL
\par  *
\par  *******************/
\par 
\par \cf1 void\cf2  EnableOpenGL (HWND hWnd, HDC *hDC, HGLRC *hRC)
\par \{
\par     PIXELFORMATDESCRIPTOR pfd;
\par     \cf1 int\cf2  iFormat;
\par 
\par     \cf0 /* get the device context (DC) */
\par \cf2     *hDC = GetDC (hWnd);
\par 
\par     \cf0 /* set the pixel format for the DC */
\par \cf2     ZeroMemory (&pfd, \cf1 sizeof\cf2  (pfd));
\par     pfd.nSize = \cf1 sizeof\cf2  (pfd);
\par     pfd.nVersion = 1;
\par     pfd.dwFlags = PFD_DRAW_TO_WINDOW | 
\par       PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER;
\par     pfd.iPixelType = PFD_TYPE_RGBA;
\par     pfd.cColorBits = 24;
\par     pfd.cDepthBits = 16;
\par     pfd.iLayerType = PFD_MAIN_PLANE;
\par     iFormat = ChoosePixelFormat (*hDC, &pfd);
\par     SetPixelFormat (*hDC, iFormat, &pfd);
\par 
\par     \cf0 /* create and enable the render context (RC) */
\par \cf2     *hRC = wglCreateContext( *hDC );
\par     wglMakeCurrent( *hDC, *hRC );
\par 
\par \}
\par 
\par 
\par \cf0 /******************
\par  * Disable OpenGL
\par  *
\par  ******************/
\par 
\par \cf1 void\cf2  DisableOpenGL (HWND hWnd, HDC hDC, HGLRC hRC)
\par \{	
\par     wglMakeCurrent (NULL, NULL);
\par     wglDeleteContext (hRC);
\par     ReleaseDC (hWnd, hDC);
\par \}
\par 
\par 
\par \cf1 #include "testvbo.h"
\par 
\par 
\par int\cf2  TestVBO(\cf1 void\cf2 )
\par \{
\par 	InitVBO();
\par 	TestShaders();
\par 	\cf1 return\cf2  0;
\par \}
\par 
\par 
\par \cf1 void\cf2  *GetAnyGLFuncAddress(\cf1 const\cf2  \cf1 char\cf2  *name)
\par \{
\par   \cf1 void\cf2  *p = (\cf1 void\cf2  *)wglGetProcAddress(name);
\par   \cf1 if\cf2 (p == 0 ||
\par     (p == (\cf1 void\cf2 *)0x1) || (p == (\cf1 void\cf2 *)0x2) || (p == (\cf1 void\cf2 *)0x3) ||
\par     (p == (\cf1 void\cf2 *)-1) )
\par   \{
\par     HMODULE module = LoadLibraryA("opengl32.dll");
\par     p = (\cf1 void\cf2  *)GetProcAddress(module, name);
\par   \}
\par 
\par   \cf1 return\cf2  p;
\par \}
\par 
\par 
\par \cf1 void\cf2  InitVBO(\cf1 void\cf2 )
\par \{
\par 	\cf0 // // // // // // // // // // // // // // // // //
\par \cf2 	
\par 	HMODULE module = LoadLibraryA("opengl32.dll");
\par 	
\par 	glGenBuffers = 				(PFNGLGENBUFFERSPROC)				GetAnyGLFuncAddress("glGenBuffers");
\par 	glBindBuffer = 				(PFNGLBINDBUFFERPROC)				GetAnyGLFuncAddress("glBindBuffer");
\par 	glBufferData = 				(PFNGLBUFFERDATAPROC)				GetAnyGLFuncAddress("glBufferData");
\par 	glVertexAttribPointer = 	(PFNGLVERTEXATTRIBPOINTERPROC)		GetAnyGLFuncAddress("glVertexAttribPointer");
\par 	glEnableVertexAttribArray = (PFNGLENABLEVERTEXATTRIBARRAYPROC)	GetAnyGLFuncAddress("glEnableVertexAttribArray");
\par 	
\par 	glCreateShader = 			(PFNGLCREATESHADERPROC)				GetAnyGLFuncAddress("glCreateShader");
\par 	glShaderSource = 			(PFNGLSHADERSOURCEPROC)				GetAnyGLFuncAddress("glShaderSource");
\par 	glCompileShader = 			(PFNGLCOMPILESHADERPROC)			GetAnyGLFuncAddress("glCompileShader");
\par 	glCreateProgram = 			(PFNGLCREATEPROGRAMPROC)			GetAnyGLFuncAddress("glCreateProgram");
\par 	glAttachShader = 			(PFNGLATTACHSHADERPROC)				GetAnyGLFuncAddress("glAttachShader");
\par 	glBindAttribLocation = 		(PFNGLBINDATTRIBLOCATIONPROC)		GetAnyGLFuncAddress("glBindAttribLocation");
\par 	glLinkProgram = 			(PFNGLLINKPROGRAMPROC)				GetAnyGLFuncAddress("glLinkProgram");
\par 	glUseProgram = 				(PFNGLUSEPROGRAMPROC)				GetAnyGLFuncAddress("glUseProgram");
\par 
\par 	glGetShaderInfoLog = 		(PFNGLGETSHADERINFOLOGPROC)			GetAnyGLFuncAddress("glGetShaderInfoLog");
\par 
\par 	\cf1 return\cf2 ;
\par \}
\par 	
\par 
\par \cf1 int\cf2  TestShaders(\cf1 void\cf2 )
\par \{
\par 	GLuint triangleVBO;
\par 	GLuint shaderProgram;
\par 	\cf1 char\cf2 * vertexSource = (\cf1 char\cf2 *)GlobalAlloc(GPTR, 0x400); 
\par 	\cf1 char\cf2 * fragmentSource = (\cf1 char\cf2 *)GlobalAlloc(GPTR, 0x400);
\par 	GLuint vertexShader, fragmentShader;
\par 	\cf1 const\cf2  \cf1 unsigned\cf2  \cf1 int\cf2  shaderAttribute = 0;
\par     GLfloat data[6][3] = \{
\par                            \{ -0.5, -1.0,  0.0  \},
\par                            \{  0.0,  1.0,  0.0  \},
\par                            \{  0.5, -1.0,  0.0  \},
\par                            \{  1.0,  1.0,  0.0  \},
\par                            \{ -2.0, -0.7,  1.0  \},
\par                            \{  1.2, -0.3,  0.0  \}
\par                        \};
\par     GLuint idx[4][3] = \{
\par                            \{ 0,  1,  2 \},
\par                            \{ 1,  2,  3 \},
\par                            \{ 2,  3,  4 \},
\par                            \{ 3,  4,  5 \}
\par                         \};
\par 	
\par 
\par 	\cf0 /*---------------------- Initialise VBO - (Note: do only once, at start of program) ---------------------*/
\par \cf2 	glGenBuffers(1, &triangleVBO);
\par 	glBindBuffer(GL_ARRAY_BUFFER, triangleVBO);
\par 	glBufferData(GL_ARRAY_BUFFER, \cf1 sizeof\cf2 (data), data, GL_STATIC_DRAW);
\par 	glVertexAttribPointer(shaderAttribute, 3, GL_FLOAT, GL_FALSE, 0, 0);
\par 	glEnableVertexAttribArray(shaderAttribute);
\par 	glBindBuffer(GL_ARRAY_BUFFER, triangleVBO);
\par 	\cf0 /*-------------------------------------------------------------------------------------------------------*/
\par 
\par \cf2 	\cf0 /*--------------------- Load Vertex and Fragment shaders from files and compile them --------------------*/
\par \cf2 	strcat(vertexSource, filetobuf("..\\\\_shaders\\\\Shader001.vert"));
\par 	strcat(fragmentSource, filetobuf("..\\\\_shaders\\\\Shader001.frag"));
\par 	vertexShader = glCreateShader(GL_VERTEX_SHADER);
\par 	fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
\par 	glShaderSource(vertexShader, 1, (\cf1 const\cf2  GLchar**)&vertexSource, 0);
\par 	glShaderSource(fragmentShader, 1, (\cf1 const\cf2  GLchar**)&fragmentSource, 0);
\par 	GlobalFree(vertexSource);
\par 	GlobalFree(fragmentSource);
\par 	glCompileShader(vertexShader);
\par 	glCompileShader(fragmentShader);
\par 	\cf0 /*-------------------------------------------------------------------------------------------------------*/
\par 
\par \cf2 	\cf0 /*-------------------- Create shader program, attach shaders to it and then link it ---------------------*/
\par \cf2 	shaderProgram = glCreateProgram();
\par 	glAttachShader(shaderProgram, vertexShader);
\par 	glAttachShader(shaderProgram, fragmentShader);
\par 	glBindAttribLocation(shaderProgram, shaderAttribute, "in_Position");
\par 	glLinkProgram(shaderProgram);
\par 	\cf0 /*-------------------------------------------------------------------------------------------------------*/
\par 
\par \cf2 	glUseProgram(shaderProgram);
\par 	glClearColor(0.0, 0.0, 0.0, 1.0);
\par 	glClear(GL_COLOR_BUFFER_BIT);
\par 	glDrawArrays(GL_TRIANGLES, 0, (\cf1 sizeof\cf2 (data) / 3) / \cf1 sizeof\cf2 (GLfloat));
\par 	\cf0 // glDrawElements(GL_TRIANGLES, sizeof(idx)/sizeof(unsigned int), GL_UNSIGNED_INT, idx);
\par 
\par \cf2 	\cf0 /*------------------------------- Info log --------------------------------------------------------------*/
\par \cf2 	\cf1 int\cf2  nLen;
\par 	\cf1 char\cf2 * szInfoLog = (\cf1 char\cf2 *)GlobalAlloc(GPTR, 0x400);
\par 	glGetShaderInfoLog(vertexShader, 0x400, &nLen, (GLchar*)szInfoLog);
\par 	buftofile("..\\\\_logs\\\\logv.txt", szInfoLog);
\par 	ZeroMemory(szInfoLog, 0x400);
\par 	glGetShaderInfoLog(fragmentShader, 0x400, &nLen, (GLchar*)szInfoLog);
\par 	buftofile("..\\\\_logs\\\\logf.txt", szInfoLog);
\par 	ZeroMemory(szInfoLog, 0x400);
\par 	GlobalFree(szInfoLog);
\par 	\cf0 /*------------------------------- ------- --------------------------------------------------------------*/
\par \cf2 	
\par 	\cf1 return\cf2  0;
\par \}
\par 
\par 
\par \cf1 const\cf2  \cf1 char\cf2 * filetobuf(\cf1 const\cf2  \cf1 char\cf2 * szFNm)
\par \{
\par 	std::fstream fs(szFNm);
\par 	std::string strBuf;
\par 	std::string strLin;
\par 	\cf1 while\cf2 (getline(fs, strLin))
\par 	\{
\par 		strBuf+=strLin;
\par 		strBuf+=std::string("\\n");
\par 	\}
\par 	fs.close();
\par 	\cf1 return\cf2  strBuf.c_str();
\par 
\par \}
\par 
\par 
\par \cf1 void\cf2  buftofile(\cf1 const\cf2  \cf1 char\cf2 * szFNm, \cf1 const\cf2  \cf1 char\cf2 * szBuf)
\par \{
\par 	std::ofstream fs(szFNm);
\par 	\cf1 if\cf2 (fs.is_open())
\par 	\{
\par 		fs<<szBuf;
\par 		fs.close();
\par 
\par 	\}
\par 	\cf1 return\cf2 ;
\par \}
\par 
\par 
\par 
\par 
\par }